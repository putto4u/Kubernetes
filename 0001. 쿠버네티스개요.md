

# **클라우드 네이티브의 핵심, 쿠버네티스(Kubernetes) 실무 완벽 가이드**

## **Page 1: 과정 개요 및 현대적 인프라의 변화**
### **1. 왜 쿠버네티스(Kubernetes)인가? **
과거에는 물리 서버 한 대에 하나의 OS를 설치하고 서비스를 운영했습니다. 이후 가상화(VM) 시대를 거쳐 현재는 컨테이너(Container) 중심의 환경으로 완전히 변화했습니다. 하지만 컨테이너의 개수가 수백, 수천 개로 늘어나면서 이를 사람이 일일이 관리하는 것은 불가능해졌습니다.

배포 자동화: 어떤 서버에 어떤 컨테이너를 올릴지 결정하고 실행합니다.

자가 치유(Self-healing): 컨테이너가 죽으면 자동으로 다시 살립니다.

스케일링(Scaling): 트래픽이 몰리면 컨테이너 수를 늘리고, 줄어들면 다시 낮춥니다.

이 모든 과정을 자동화해 주는 도구가 바로 **쿠버네티스(K8s)**입니다.

### **1.1. 왜 다시 쿠버네티스인가?**

전통적인 서버 운영 방식에서 컨테이너로의 전환은 단순히 기술의 변화가 아니라 **'운영의 패러다임'** 변화입니다.

* **Monolithic to Microservices:** 거대한 서비스가 수백 개의 작은 서비스로 쪼개지며 관리 포인트가 급증했습니다.
* **Immutable Infrastructure:** 서버를 수정하는 것이 아니라, 새로 구운 이미지를 배포하고 기존 것은 버리는 방식이 표준이 되었습니다.
* **결론:** 수천 개의 컨테이너를 관리하기 위한 **'운영 자동화 로봇'**이 필요해졌고, 그 표준이 바로 [Kubernetes (K8s)](https://kubernetes.io/)입니다.

### **1.2. 학습 목표**

1. 쿠버네티스의 선언적 인터페이스(Declarative API)와 원하는 상태(Desired State) 메커니즘을 이해한다.
2. 핵심 오브젝트(Pod, Deployment, Service, Ingress)의 연동 원리를 파악한다.
3. 실무 환경에서의 네트워크, 스토리지 구성 및 트러블슈팅 능력을 배양한다.

---

## **Page 2: 쿠버네티스 아키텍처 - 클러스터의 내부 구조**

### **2.1. Control Plane (마스터 노드): 클러스터의 뇌**

* **kube-apiserver:** 모든 통신의 중심입니다. 유저의 `kubectl` 명령이나 노드의 보고를 받아 처리합니다.
* **etcd:** 클러스터의 상태 정보를 담는 고가용성 Key-Value 저장소입니다. **(백업의 핵심)**
* **kube-scheduler:** 리소스 제약 조건을 고려해 새로운 Pod를 어떤 노드에 배치할지 결정합니다.
* **kube-controller-manager:** 현재 상태를 원하는 상태로 맞추기 위해 끊임없이 루프를 도는 프로세스입니다.

### **2.2. Worker Node: 실제 워크로드 수행**

* **kubelet:** 마스터와 통신하며 컨테이너의 생명주기를 직접 관리합니다.
* **kube-proxy:** Pod로 가는 네트워크 트래픽을 포워딩하며 로드밸런싱 규칙을 관리합니다. (iptables 또는 IPVS 모드)
* **Container Runtime:** 컨테이너를 실행하는 실제 엔진입니다. 최근에는 Docker 대신 [containerd](https://containerd.io/)가 표준입니다.

---

## **Page 3: 쿠버네티스 오브젝트 1 - Pod & ReplicaSet**

### **3.1. Pod: 최소 배포 단위**

Pod는 하나 이상의 컨테이너 묶음입니다.

* **특징:** Pod 내의 컨테이너들은 `localhost`로 서로 통신하며, 같은 네트워크 네임스페이스와 스토리지를 공유합니다.
* **실무 팁:** 1개 Pod에는 1개 앱 컨테이너를 두는 것이 기본이나, 로그 수집이나 프록시를 위한 **Sidecar 패턴** 컨테이너를 추가하는 경우가 많습니다.

### **3.2. ReplicaSet: 개수 보장**

Pod가 죽었을 때 지정된 숫자만큼 다시 살려내는 역할을 합니다. 유저가 직접 만들기보다는 Deployment를 통해 관리하는 것이 일반적입니다.

```yaml
# Pod 정의 예시
apiVersion: v1
kind: Pod
metadata:
  name: my-app-pod
  labels:
    app: backend
spec:
  containers:
  - name: main-app
    image: my-registry/app:v1

```

---

## **Page 4: 쿠버네티스 오브젝트 2 - Deployment (무중단 배포의 핵심)**

### **4.1. 배포 전략 (Deployment Strategies)**

Deployment는 앱의 업데이트와 롤백을 관리합니다.

1. **Rolling Update:** 구버전 Pod를 하나씩 줄이고 신버전을 하나씩 늘려 서비스 중단을 방지합니다. (기본값)
2. **Recreate:** 구버전을 모두 죽인 후 신버전을 띄웁니다. (일시적 중단 발생)

### **4.2. 실전 예제: Deployment YAML**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-deploy
spec:
  replicas: 3
  selector:
    matchLabels:
      run: web-server
  template:
    metadata:
      labels:
        run: web-server
    spec:
      containers:
      - name: nginx-web
        image: nginx:1.21
        resources:
          requests: # 최소 필요 자원
            cpu: "250m"
            memory: "64Mi"
          limits:   # 최대 허용 자원 (OOM 방지)
            cpu: "500m"
            memory: "128Mi"

```

---

## **Page 5: 쿠버네티스 서비스(Service) - 고정된 입구**

### **5.1. 서비스 타입 4가지**

1. **ClusterIP:** 클러스터 내부에서만 접근 가능한 기본 IP.
2. **NodePort:** 모든 워커 노드의 특정 포트를 열어 외부 접속 허용 (30000-32767).
3. **LoadBalancer:** 클라우드(AWS, GCP 등) 로드밸런서와 연동하여 공인 IP 부여.
4. **ExternalName:** 외부 도메인을 내부 서비스처럼 사용.

### **5.2. 서비스가 Pod를 찾는 방법 (Label Selector)**

서비스는 IP가 아니라 **Label Selector**를 통해 Pod를 찾습니다. Pod가 죽어서 새로 생성되어 IP가 바뀌어도 Label만 같으면 서비스는 자동으로 트래픽을 전달합니다.

---

## **Page 6: 인그레스(Ingress) - L7 로드밸런싱**

### **6.1. Ingress의 필요성**

NodePort나 LoadBalancer 서비스만으로는 도메인 기반 라우팅이나 SSL/TLS 인증서 관리가 어렵습니다. 인그레스는 이를 해결하는 **스마트한 관문**입니다.

### **6.2. 주요 기능**

* **Host-based Routing:** `shop.example.com`과 `blog.example.com`을 다른 서비스로 분기.
* **Path-based Routing:** `/api`는 백엔드로, `/`는 프론트엔드로 분기.
* **SSL/TLS 터미네이션:** 인증서 처리를 한곳에서 관리.

> **💡 자주 하는 실수:** Ingress 리소스만 만든다고 작동하지 않습니다. 클러스터에 [의심스러운 링크 삭제됨] 같은 실제 엔진이 설치되어 있어야 합니다.

---

## **Page 7: 데이터의 영속성 - Storage (PV & PVC)**

### **7.1. Ephemeral vs Persistent**

컨테이너의 파일 시스템은 일시적입니다. DB 데이터 등을 보존하려면 외부 스토리지가 필요합니다.

### **7.2. PV/PVC 추상화 모델**

* **PersistentVolume (PV):** 인프라 관리자가 생성한 실제 저장 공간 (NFS, AWS EBS 등).
* **PersistentVolumeClaim (PVC):** 개발자가 "나 10GB 공간 필요해"라고 요청하는 티켓.
* **StorageClass:** PVC 요청 시 자동으로 PV를 생성해주는 **'동적 프로비저닝'** 도구.

---

## **Page 8: 설정 관리 - ConfigMap & Secret**

### **8.1. ConfigMap**

환경 변수, 설정 파일(nginx.conf 등)을 이미지와 분리하여 관리합니다. 이미지를 다시 빌드하지 않고 설정만 바꿔 앱의 동작을 제어할 수 있습니다.

### **8.2. Secret**

DB 비밀번호, API 키 등 민감 정보를 저장합니다. base64로 인코딩되지만, 실제 보안을 위해 [HashiCorp Vault](https://www.vaultproject.io/)나 클라우드 KMS 연동을 권장합니다.

---

## **Page 9: 실무 트러블슈팅 가이드 (Troubleshooting)**

가장 빈번하게 발생하는 이슈와 해결 명령어입니다.

1. **Pod가 안 떠요 (Pending):** `kubectl describe pod [이름]`
* 원인: 노드 리소스 부족, 노드 셀렉터 불일치.


2. **Pod가 자꾸 죽어요 (CrashLoopBackOff):** `kubectl logs [이름] --previous`
* 원인: 앱 설정 오류, 엔트리포인트 실행 실패.


3. **이미지를 못 가져와요 (ImagePullBackOff):**
* 원인: 이미지 이름 오타, Private 레지스트리 인증 실패.


4. **네트워크 통신이 안 돼요:** `kubectl exec -it [이름] -- curl [서비스명]`
* 원인: 서비스 셀렉터 오타, 네트워크 폴리시 차단.



---

## **Page 10: 향후 과제 및 생태계 (Ecosystem)**

### **10.1. 관리 효율화 도구**

* **[Helm](https://helm.sh/):** 쿠버네티스의 'App Store'. 복잡한 리소스를 한 번에 설치.
* **[ArgoCD](https://argoproj.github.io/cd/):** Git에 코드를 푸시하면 자동으로 클러스터에 반영하는 GitOps의 표준.
* **[Lens](https://k8slens.dev/):** 쿠버네티스 관리를 위한 가장 강력한 GUI 대시보드.

### **10.2. 마무리: 전문가를 위한 조언**

쿠버네티스는 어렵습니다. 하지만 핵심은 **"상태(State)를 정의하고, 엔진에 맡긴다"**는 철학을 이해하는 것입니다.   
추상화된 레이어 뒤에서 실제 네트워크 인터페이스(CNI)와 스토리지 인터페이스(CSI)가 어떻게 동작하는지 파디그(dig)하는 습관이 중요합니다.

---

**Reference:**

* [Kubernetes Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/)
* [CNCF Cloud Native Landscape](https://landscape.cncf.io/)

---

**Next**

1. 네트워크나 보안 심화
2. `kubectl` 실습 시나리오(Hands-on Lab)
